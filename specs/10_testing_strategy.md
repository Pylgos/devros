# テスト戦略 (Testing Strategy)

## 1. 基本方針 (Philosophy)
devrosは「ビルド・デプロイ」という信頼性が極めて重要なタスクを担うため、**堅牢性**と**正確性**を最優先します。特に、誤ったビルドアーティファクトの生成や、環境変数の不適切な設定は、ユーザーのシステム破壊やロボットの予期せぬ動作につながるため、厳格なテストが必要です。

## 2. テスト階層 (Testing Pyramid)

### 2.1 単体テスト (Unit Tests)
ロジックの正しさを検証します。I/Oを行う部分と計算を行う部分を分離し、計算ロジック（純粋関数）に対して徹底的なテストを行います。

*   **対象**:
    *   **依存グラフ操作**: ノード追加、トポロジカルソート、循環検知（グラフデータ構造に対する操作）。
    *   **ハッシュ計算ロジック**: ファイルメタデータや文字列入力に対するハッシュ生成。
    *   **設定マージロジック**: 2つの設定構造体のマージ結果検証。
    *   **環境変数計算**: 抽象化された定義データに基づく環境変数の加工ロジック。
*   **手法**:
    *   **Functional Core, Imperative Shell**: データの収集（I/O）と処理（Logic）を分け、処理部分を重点的にテストします。
    *   エッジケース（空データ、不正な文字列など）の網羅。

### 2.2 ファイルシステム/統合テスト (Filesystem & Integration Tests)
`tempfile` クレートを活用し、**隔離された一時ディレクトリ**上で実際のファイルシステム操作を検証します。無理なモック化は避け、実挙動の正しさを保証します。

*   **対象**:
    *   **パッケージ探索**: `glob`/`walkdir` を使用したファイル探索が、意図通りにファイルを見つけ、除外ルール（`.gitignore`等）に従っているか。
    *   **アーティファクト生成**: ファイルの作成、コピー、シンボリックリンク作成が正しく行われるか。
    *   **CLIコマンド**: `devros build` 等のコマンド全体を通した動作検証。
*   **手法**:
    *   テストごとに一時ディレクトリを作成し、そこにダミーのワークスペース構造（`package.xml`など）を展開して実行します。
    *   `assert_fs` や `predicates` クレートを使用し、ファイル存在確認や内容の一致を宣言的に記述します。

### 2.3 システム/E2Eテスト (End-to-End Tests)
開発環境（Dev Container）やCIランナーなど、ROS 2がインストールされた実際の環境上で、ビルドから実行までのフローを検証します。

*   **環境**:
    *   現在稼働中のROS 2環境（Humble/Jazzy等）を直接利用します。
    *   新たなコンテナの起動（Docker-in-Docker等）は行いません。
*   **対象**:
    *   標準的なサンプルパッケージのビルド成功。
    *   生成された `setup.bash` の source と `ros2 run` の実行確認。
    *   Jobserverによる並列数の制御確認。

## 3. テスト容易性設計 (Design for Testability)

### 3.1 限定的な抽象化 (Limited Abstraction)
すべてのI/Oを抽象化するのではなく、副作用が大きく制御が難しいもの、または単体テストの効率を著しく下げるものに限定して抽象化（Trait化）します。

*   **コマンド実行 (`CommandRunner`)**:
    *   外部プロセス（CMake, Python等）の実行は、実行時間や環境依存性が高いため、モック化してコマンド生成ロジックとハンドリングをテスト可能にします。
*   **時刻/乱数**:
    *   決定的なテストを行うため、現在時刻の取得などは抽象化します。

### 3.2 ロジックとI/Oの分離 (Separation of Concerns)

実装においては、以下のような構造を意識します。

**悪い例 (I/Oとロジックの混在):**
```rust
fn find_and_sort_packages(root: &Path) -> Result<Vec<Package>> {
    // 1. walkdirで探索 (I/O)
    // 2. package.xml読み込み (I/O)
    // 3. 依存解析・ソート (Logic) -> ここだけテストしたいのにI/Oが邪魔
}
```

**良い例 (分離):**
```rust
// I/O: ファイルシステムから情報を集めて構造体にする
fn scan_workspace(root: &Path) -> Result<WorkspaceData> { ... }

// Logic: 構造体を受け取って計算する (単体テスト容易)
fn resolve_dependencies(data: &WorkspaceData) -> Result<Vec<Package>> { ... }
```

## 4. CI/CDパイプライン

GitHub Actions等のCI環境を利用して自動テストを実施します。

*   **前提**: CIランナーにはROS 2およびビルドツールがプリインストールされていること。
*   **トリガー**: Pull Request, MainブランチへのPush
*   **ジョブ**:
    1.  **Check**: `cargo fmt --check`, `cargo clippy -- -D warnings`
    2.  **Test**: `cargo test` (Unit & Integration)
    3.  **Build**: `cargo build --release`
