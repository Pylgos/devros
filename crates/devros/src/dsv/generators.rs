//! Generator functions for setup scripts and DSV files
//!
//! This module generates colcon-compatible environment files for ROS 2 packages.
//! The generated files follow the same format as colcon to ensure compatibility
//! with existing ROS 2 tools and workflows.

use camino::{Utf8Path, Utf8PathBuf};
use std::collections::HashSet;

use crate::Result;

/// Generate package.dsv content for an ament_cmake package
///
/// For ament_cmake packages, the package.dsv sources the local_setup files
/// that are generated by ament_cmake itself during the CMake install step.
pub fn generate_ament_cmake_package_dsv(package_name: &str) -> String {
    // ament_cmake generates local_setup files, so package.dsv just sources them
    // The order is: dsv first for environment hooks processing, then shell scripts
    format!(
        "source;share/{}/local_setup.dsv\n\
         source;share/{}/local_setup.sh\n\
         source;share/{}/local_setup.bash\n\
         source;share/{}/local_setup.zsh\n",
        package_name, package_name, package_name, package_name
    )
}

/// Generate package.dsv content for an ament_python package
///
/// For ament_python packages, we generate direct hooks in the package.dsv
/// since ament_python doesn't generate local_setup files like ament_cmake.
/// This follows colcon's behavior for ament_python packages.
pub fn generate_ament_python_package_dsv(_package_name: &str, hooks: &[&str]) -> String {
    let mut lines = Vec::new();

    for hook in hooks {
        lines.push(format!("source;{}", hook));
    }

    lines.join("\n") + "\n"
}

/// Generate the colcon-core package marker file content
///
/// This file is placed at `share/colcon-core/packages/<pkg>` and contains
/// the runtime dependencies of the package, separated by colons.
/// It's used by `_local_setup_util_sh.py` to determine the topological order
/// for sourcing package setup scripts.
pub fn generate_colcon_marker_file(run_dependencies: &[&str]) -> String {
    // Filter to only include dependencies that are in the workspace
    // Empty dependencies result in an empty file
    run_dependencies.join(":")
}

/// Generate workspace local_setup.sh content (colcon-compatible)
///
/// This is the main entry point for setting up the current workspace's environment.
/// It calls `_local_setup_util_sh.py` to get the topological order of packages
/// and sources each package's setup script.
pub fn generate_workspace_local_setup_sh(install_dir: &Utf8Path) -> String {
    include_str!("local_setup.sh.template").replace("{{INSTALL_DIR}}", install_dir.as_str())
}

/// Generate workspace setup.sh content (colcon-compatible)
///
/// This is the chain script that sources any parent workspaces first,
/// then sources the current workspace's local_setup.sh.
pub fn generate_workspace_setup_sh(
    install_dir: &Utf8Path,
    chained_prefix_paths: &[&str],
) -> String {
    let mut chained_section = String::new();

    if !chained_prefix_paths.is_empty() {
        chained_section.push_str("\n# source chained prefixes\n");
        for prefix in chained_prefix_paths.iter().rev() {
            chained_section.push_str(&format!(
                r#"# setting COLCON_CURRENT_PREFIX avoids relying on the build time prefix of the sourced script
COLCON_CURRENT_PREFIX="{prefix}"
_colcon_prefix_chain_sh_source_script "$COLCON_CURRENT_PREFIX/local_setup.sh"

"#,
                prefix = prefix
            ));
        }
    }

    include_str!("setup.sh.template")
        .replace("{{INSTALL_DIR}}", install_dir.as_str())
        .replace("{{CHAINED_PREFIX_PATHS}}", &chained_section)
}

/// Generate workspace setup.bash content (colcon-compatible)
///
/// This simply sources setup.sh from a bash context.
pub fn generate_workspace_setup_bash() -> String {
    r#"# generated from colcon_bash/shell/template/prefix_chain.bash.em

# This script extends the environment with the environment of other prefix
# paths which were sourced when this file was generated as well as all packages
# contained in this prefix path.

# get build time prefix (if it exists)
COLCON_CURRENT_PREFIX="$(builtin cd "`dirname "${BASH_SOURCE[0]}"`" > /dev/null && pwd)"
. "$COLCON_CURRENT_PREFIX/setup.sh"
"#
    .to_string()
}

/// Generate workspace setup.zsh content (colcon-compatible)
pub fn generate_workspace_setup_zsh() -> String {
    r#"# generated from colcon_zsh/shell/template/prefix_chain.zsh.em

# This script extends the environment with the environment of other prefix
# paths which were sourced when this file was generated as well as all packages
# contained in this prefix path.

COLCON_CURRENT_PREFIX="$(builtin cd -q "`dirname "${(%):-%N}"`" > /dev/null && pwd)"
. "$COLCON_CURRENT_PREFIX/setup.sh"
"#
    .to_string()
}

/// Generate _local_setup_util_sh.py content (colcon-compatible)
///
/// This Python script is used by local_setup.sh to determine the topological
/// order in which to source package setup scripts.
pub fn generate_local_setup_util_py() -> String {
    include_str!("prefix_util.py.template").to_string()
}

/// Generate .colcon_install_layout file
///
/// This marker file indicates the install layout used (isolated or merged).
pub fn generate_colcon_install_layout(merged: bool) -> String {
    if merged {
        "merged\n".to_string()
    } else {
        "isolated\n".to_string()
    }
}

/// Collect all workspace install directories for packages
/// Returns the list of run dependencies that are in the workspace
pub fn filter_workspace_dependencies<'a>(
    run_deps: impl Iterator<Item = &'a str>,
    workspace_packages: &HashSet<String>,
) -> Vec<String> {
    run_deps
        .filter(|dep| workspace_packages.contains(*dep))
        .map(|s| s.to_string())
        .collect()
}

/// Write colcon marker files for a package
///
/// Creates the `share/colcon-core/packages/<pkg>` marker file
/// with the package's runtime dependencies.
pub fn write_colcon_marker_file(
    install_dir: &Utf8Path,
    package_name: &str,
    workspace_run_deps: &[&str],
) -> Result<Utf8PathBuf> {
    let marker_dir = install_dir
        .join("share")
        .join("colcon-core")
        .join("packages");
    std::fs::create_dir_all(&marker_dir)?;

    let marker_path = marker_dir.join(package_name);
    let content = generate_colcon_marker_file(workspace_run_deps);
    std::fs::write(&marker_path, content)?;

    Ok(marker_path)
}
